<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Load Multiple CSV Matrices</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
</head>

<body>
	<h2>Loading CSV Matrices...</h2>

	<!-- function simulateMarkov(transitionMatrix, initialState, steps) {
	let result = [initialState];
	
	for (let step = 0; step < steps; step++) { const prevState=result[result.length - 1]; const nextState=[0, 0, 0]; for
		(let to=0; to < 3; to++) { for (let from=0; from < 3; from++) { nextState[to] +=prevState[from] *
		transitionMatrix[from][to]; } } result.push(nextState); } return result; } const transitionMatrix=[ [0.95, 0.03,
		0.02], [0.10, 0.80, 0.10], [0.09, 0.01, 0.90] ]; const initialState=[1000, 0, 0]; // Initial volumes in A, B, C
		const steps=5; const simulationResult=simulateMarkov(transitionMatrix, initialState, steps); // Display results
		simulationResult.forEach((state, i)=> {
		console.log(`Step ${i}: A=${state[0].toFixed(2)}, B=${state[1].toFixed(2)}, C=${state[2].toFixed(2)}`);
		}); -->
<!-- 
		let lengthOfArr = speakers.length;
		
		while (lengthOfArr > 1) {
		
		// step1: Generate a random number from 0 to 4
		let randomNumber = Math.floor(Math.random() * lengthOfArr);
		
		// step2: Pick a speaker from the speakers list using the random number
		sequence_speakers[randomNumber] = speakers[randomNumber];
		console.log(sequence_speakers);
		
		//step3: update the speakers list to only have remaining guys and then repeat the steps:
		
		speakers.splice(randomNumber,1);
		
		//step4: update the length so the random number can adjust accordingly
		lengthOfArr = speakers.length;
		
		}
		
		//step5: append the final speaker into the lisr
		sequence_speakers.push(...speakers);
		console.log(sequence_speakers) -->



	<script type="module">

		// Declare variables to use
		 let speakers = ['First Citizen', 'All', 'Second Citizen', 'Menenius', 'Marcius'];
		 
		 let sequence_speakers = [];

		 let item_not_repeat = [];

		// Create a function that takes in csv files with matrices in them and declare the transition matrix

		async function loadMatrixFromCSV(filePath) {
			try {
				const response = await fetch(filePath);
				if (!response.ok) throw new Error(`Failed to fetch ${filePath}`);
				const csvText = await response.text();

				const parsed = Papa.parse(csvText.trim(), { skipEmptyLines: true });
				const data = parsed.data;

				const matrix = data.slice(1).map(row =>
					row.slice(1).map(cell => parseFloat(cell))
				);

				return matrix;
			} catch (error) {
				console.error(`‚ùå Error loading ${filePath}:`, error);
				return null;
			}
		}

		const speaker_transition_matrix = await loadMatrixFromCSV('speaker_transition_matrix.csv');


		 // Set up the algorithm to apply the markov chain:
		 function simulateMarkov(transitionMatrix, currState) {

			const nextState = new Array(currState.length).fill(0);

			for (let j = 0; j < transitionMatrix[0].length; j++) {
				const stateHolder = new Array(currState.length).fill(0);

				for (let i = 0; i < currState.length; i++) {
					const calc = currState[i] * transitionMatrix[i][j];
					stateHolder[i] = calc;
				}

				nextState[j] = stateHolder.reduce((a, b) => a + b, 0);
			}

			return nextState;
		}
		

		 // iteration 1:

		 //step 1: get the first speaker
		 
		 const first_speaker = Math.floor(Math.random() * 5);
		 item_not_repeat[0] = first_speaker;

		 sequence_speakers[0] = speakers[first_speaker];

		 //step2: make an array for initial current state
		 let current_state = Array(5).fill(0);
		 current_state[first_speaker] = 1;

		 //step3: apply the transition matrix to get the next state

		 let next_state = simulateMarkov(speaker_transition_matrix, current_state);

		 
		 console.log(first_speaker);
		 console.log(item_not_repeat);
		 console.log(sequence_speakers);
		 console.log(current_state);
		 console.log(speaker_transition_matrix);
		 console.log(next_state);

	</script>
</body>

</html>