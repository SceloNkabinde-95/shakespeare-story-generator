<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Load Multiple CSV Matrices</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
</head>

<body>
	<h2>Loading CSV Matrices...</h2>

	<!-- function simulateMarkov(transitionMatrix, initialState, steps) {
	let result = [initialState];
	
	for (let step = 0; step < steps; step++) { const prevState=result[result.length - 1]; const nextState=[0, 0, 0]; for
		(let to=0; to < 3; to++) { for (let from=0; from < 3; from++) { nextState[to] +=prevState[from] *
		transitionMatrix[from][to]; } } result.push(nextState); } return result; } const transitionMatrix=[ [0.95, 0.03,
		0.02], [0.10, 0.80, 0.10], [0.09, 0.01, 0.90] ]; const initialState=[1000, 0, 0]; // Initial volumes in A, B, C
		const steps=5; const simulationResult=simulateMarkov(transitionMatrix, initialState, steps); // Display results
		simulationResult.forEach((state, i)=> {
		console.log(`Step ${i}: A=${state[0].toFixed(2)}, B=${state[1].toFixed(2)}, C=${state[2].toFixed(2)}`);
		}); -->
<!-- 
		let lengthOfArr = speakers.length;
		
		while (lengthOfArr > 1) {
		
		// step1: Generate a random number from 0 to 4
		let randomNumber = Math.floor(Math.random() * lengthOfArr);
		
		// step2: Pick a speaker from the speakers list using the random number
		sequence_speakers[randomNumber] = speakers[randomNumber];
		console.log(sequence_speakers);
		
		//step3: update the speakers list to only have remaining guys and then repeat the steps:
		
		speakers.splice(randomNumber,1);
		
		//step4: update the length so the random number can adjust accordingly
		lengthOfArr = speakers.length;
		
		}
		
		//step5: append the final speaker into the lisr
		sequence_speakers.push(...speakers);
		console.log(sequence_speakers) -->


		
		<!-- 
		
		

					// Declare variables to use
			let speakers = ['First Citizen', 'All', 'Second Citizen', 'Menenius', 'Marcius'];

			// Create a function that takes in csv files with matrices in them and declare the transition matrix
			async function loadMatrixFromCSV(filePath) {
				try {
					const response = await fetch(filePath);
					if (!response.ok) throw new Error(`Failed to fetch ${filePath}`);
					const csvText = await response.text();

					// Use PapaParse to parse CSV text
					const parsed = Papa.parse(csvText.trim(), { skipEmptyLines: true });
					const data = parsed.data;

					//Remove row and column labels from matrix
					const matrix = data.slice(1).map(row =>
						row.slice(1).map(cell => parseFloat(cell))
					);

					return matrix;
				} catch (error) {
					console.error(`❌ Error loading ${filePath}:`, error);
					return null;
				}
			}

			const speaker_transition_matrix = await loadMatrixFromCSV('speaker_transition_matrix.csv');



			// Function to simulate Markov chain using a transition matrix
			function simulateMarkov(transitionMatrix, currState) {
				const nextState = new Array(currState.length).fill(0);

				for (let j = 0; j < transitionMatrix[0].length; j++) {
					const stateHolder = new Array(currState.length).fill(0);

					for (let i = 0; i < currState.length; i++) {
						const calc = currState[i] * transitionMatrix[i][j];
						stateHolder[i] = calc;
					}

					nextState[j] = stateHolder.reduce((a, b) => a + b, 0);
				}

				return nextState;
			}

			// Helper function to avoid repeats
				function getMaxIndexExcluding(nextState, noRepeat) {
					let maxVal = -Infinity;
					let maxIndex = -1;

					for (let i = 0; i < nextState.length; i++) {
						if (!noRepeat.includes(i) && nextState[i] > maxVal) {
							maxVal = nextState[i];
							maxIndex = i;
						}
					}

					return maxIndex;
			}

			let item_not_repeat = [];
			let sequence_speakers = new Array(speakers.length).fill("")

				// iteration 1:

				//step 1: get the first speaker
				let speaker = Math.floor(Math.random() * speakers.length);
				item_not_repeat[0] = speaker;

				sequence_speakers[0] = speakers[speaker];

				//step2: make an array for initial current state
				let current_state = Array(speakers.length).fill(0);
				current_state[speaker] = 1;

				//step3: apply the transition matrix to get the next state
				let next_state = simulateMarkov(speaker_transition_matrix, current_state);

				//step4: get the next position from the next_state
				speaker = getMaxIndexExcluding(next_state, item_not_repeat);

				// iterations 2 to speaker's list length minus 1
				let count = 1;
				const maxSteps = speakers.length - 1;

				while (count < maxSteps && speaker !== -1) {

				//step1: Update the no repeat index list and get next speaker
				item_not_repeat[count] = speaker; 
				sequence_speakers[count] = speakers[speaker];
					
				//step2: update current state as previous next state:
				
				current_state = next_state; 
				
				//step3: apply transition matrix to get the next state
				next_state = simulateMarkov(speaker_transition_matrix, current_state);
				
				//step4: get the next position from the next_state
				 speaker = getMaxIndexExcluding(next_state, item_not_repeat);
				 
				 //step5: update the counter 
				 count +=1; 
				}

					
				//iteration final 
				
				//define the item not in the sequence list but in speakers list
				let missing = speakers.find(item => !sequence_speakers.includes(item));

				//find the index where there's a missing name
				let emptyIndex;
				sequence_speakers.forEach((value, index) => {
						if (value === '') {
							emptyIndex = index;
						}
					  });
					  

				//update the sequence with the missing speaker
				sequence_speakers[emptyIndex] = missing;
		

		 console.log(speakers);
		 console.log(missing);
		 console.log(sequence_speakers);
		 console.log(item_not_repeat);
		 
		 //console.log(current_state);
		 //console.log(next_state);



				} -->





<!-- 
		 -->


	<script type="module">

	// Create a function that takes in csv files with matrices in them and declare the transition matrix
		async function loadMatrixFromCSV(filePath) {
			try {
				const response = await fetch(filePath);
				if (!response.ok) throw new Error(`Failed to fetch ${filePath}`);
				const csvText = await response.text();

				// Use PapaParse to parse CSV text
				const parsed = Papa.parse(csvText.trim(), { skipEmptyLines: true });
				const data = parsed.data;

				//Remove row and column labels from matrix
				const matrix = data.slice(1).map(row =>
					row.slice(1).map(cell => parseFloat(cell))
				);

				return matrix;
			} catch (error) {
				console.error(`❌ Error loading ${filePath}:`, error);
				return null;
			}
		}

		// Create a function that parses csv files
			async function loadCSV(filePath) {
				try {
					const response = await fetch(filePath);
					if (!response.ok) throw new Error(`Failed to fetch ${filePath}`);
					const csvText = await response.text();

					// Use PapaParse to parse CSV text
					const parsed = Papa.parse(csvText.trim(), { skipEmptyLines: true });
					const data = parsed.data;

					return data;
				} catch (error) {
					console.error(`❌ Error loading ${filePath}:`, error);
					return null;
				}
		}

		// Function to simulate Markov chain using a transition matrix
		function simulateMarkov(transitionMatrix, currState) {
			const nextState = new Array(currState.length).fill(0);

			for (let j = 0; j < transitionMatrix[0].length; j++) {
				const stateHolder = new Array(currState.length).fill(0);

				for (let i = 0; i < currState.length; i++) {
					const calc = currState[i] * transitionMatrix[i][j];
					stateHolder[i] = calc;
				}

				nextState[j] = stateHolder.reduce((a, b) => a + b, 0);
			}

			return nextState;
		}

		// Helper function to avoid repeats
		function getMaxIndexExcluding(nextState, noRepeat) {
			let maxVal = -Infinity;
			let maxIndex = -1;

			for (let i = 0; i < nextState.length; i++) {
				if (!noRepeat.includes(i) && nextState[i] > maxVal) {
					maxVal = nextState[i];
					maxIndex = i;
				}
			}

			return maxIndex;
		}

			const all_transition_matrix = await loadMatrixFromCSV('all_transition_matrix.csv');

			const all_word_count = await loadMatrixFromCSV('all_word_count.csv');

			let all_speech_list = await loadCSV('all_speech_list.csv');
			// Select from 2nd row onward (index 1) and only the 2nd column (index 1)
			all_speech_list = all_speech_list.slice(1).map(row => row[1]);


			const first_citizen_transition_matrix = await loadMatrixFromCSV('first_citizen_transition_matrix.csv');

			const first_citizen_word_count = await loadMatrixFromCSV('first_citizen_word_count.csv');

			let first_citizen_speech_list = await loadCSV('first_citizen_speech_list.csv');
			// Select from 2nd row onward (index 1) and only the 2nd column (index 1)
			first_citizen_speech_list = first_citizen_speech_list.slice(1).map(row => row[1]);



			function speechGenerator(transitionMatrix,wordCount,speechList) {

				//Choose the speech's length (how many number of words) at random by using the word count of the speaker's speeches saved in all_word_count

				let speech_length_selector = Math.floor(Math.random() * wordCount.length);
				// Now the number of iterations will be speech_length
				let speech_length = wordCount[speech_length_selector];

				//Declare the list to hold the generated words
				let sequence_speech = new Array(speech_length).fill("")

				//Declare a variable to store repeated indexes of words
				let item_not_repeat = [];


				if (speech_length === 1) {

					//step 1: get the first word from the list of words
					let word = Math.floor(Math.random() * speechList.length);
					item_not_repeat[0] = word;

					sequence_speech[0] = speechList[word];

				}
				
				else if (speech_length === 2) {

				// iteration 1:

				//step 1: get the first word from the list of words
				let word = Math.floor(Math.random() * speechList.length);
				item_not_repeat[0] = word;

				sequence_speech[0] = speechList[word];

				//step2: make an array for initial current state
				let current_state = Array(speechList.length).fill(0);
				current_state[word] = 1;

				//step3: apply the transition matrix to get the next state
				let next_state = simulateMarkov(transitionMatrix, current_state);

				//step4: get the next position from the next_state
				word = getMaxIndexExcluding(next_state, item_not_repeat);

				// iteration 2:

				sequence_speech[1] = speechList[word];

				}

				else if (speech_length > 2) {

					// iteration 1:

					//step 1: get the first word from the list of words
					let word = Math.floor(Math.random() * speechList.length);
					item_not_repeat[0] = word;

					sequence_speech[0] = speechList[word];

					//step2: make an array for initial current state
					let current_state = Array(speechList.length).fill(0);
					current_state[word] = 1;

					//step3: apply the transition matrix to get the next state
					let next_state = simulateMarkov(transitionMatrix, current_state);

					//step4: get the next position from the next_state
					word = getMaxIndexExcluding(next_state, item_not_repeat);


					// iterations 2 to final length of speach
					let count = 1;
					const maxSteps = speech_length;

					while (count < maxSteps && word !== -1) { 

						//step1: Update the no repeat index list and get next word
						item_not_repeat[count] = word; 
						sequence_speech[count] = speechList[word]; 
						
						//step2: update current state as previous next state: 
						current_state = next_state; 
						
						//step3: apply transition matrix to get the next state
						next_state = simulateMarkov(transitionMatrix, current_state); 
						
						//step4: get the next position from the next_state
						word = getMaxIndexExcluding(next_state, item_not_repeat);

						//step5: update the counter 
						count +=1; 
					} 
				}

			
				// save the speech into one sentence
				const speech = [sequence_speech.join(" ")];

			return speech;

			}

		const all_speech = speechGenerator(all_transition_matrix,all_word_count, all_speech_list);

		const first_citizen_speech = speechGenerator(first_citizen_transition_matrix, first_citizen_word_count, first_citizen_speech_list);

		console.log(all_speech);
		console.log(first_citizen_speech);
		//console.log(current_state[word]);
		//console.log(sequence_speech);
		//console.log(all_speech);
		//console.log(current_state);
		//console.log(all_transition_matrix[0]);		

	</script>
</body>

</html>