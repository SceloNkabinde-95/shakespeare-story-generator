<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Load Multiple CSV Matrices</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
</head>

<body>
	<h2>Loading CSV Matrices...</h2>

	<!-- function simulateMarkov(transitionMatrix, initialState, steps) {
	let result = [initialState];
	
	for (let step = 0; step < steps; step++) { const prevState=result[result.length - 1]; const nextState=[0, 0, 0]; for
		(let to=0; to < 3; to++) { for (let from=0; from < 3; from++) { nextState[to] +=prevState[from] *
		transitionMatrix[from][to]; } } result.push(nextState); } return result; } const transitionMatrix=[ [0.95, 0.03,
		0.02], [0.10, 0.80, 0.10], [0.09, 0.01, 0.90] ]; const initialState=[1000, 0, 0]; // Initial volumes in A, B, C
		const steps=5; const simulationResult=simulateMarkov(transitionMatrix, initialState, steps); // Display results
		simulationResult.forEach((state, i)=> {
		console.log(`Step ${i}: A=${state[0].toFixed(2)}, B=${state[1].toFixed(2)}, C=${state[2].toFixed(2)}`);
		}); -->
<!-- 
		let lengthOfArr = speakers.length;
		
		while (lengthOfArr > 1) {
		
		// step1: Generate a random number from 0 to 4
		let randomNumber = Math.floor(Math.random() * lengthOfArr);
		
		// step2: Pick a speaker from the speakers list using the random number
		sequence_speakers[randomNumber] = speakers[randomNumber];
		console.log(sequence_speakers);
		
		//step3: update the speakers list to only have remaining guys and then repeat the steps:
		
		speakers.splice(randomNumber,1);
		
		//step4: update the length so the random number can adjust accordingly
		lengthOfArr = speakers.length;
		
		}
		
		//step5: append the final speaker into the lisr
		sequence_speakers.push(...speakers);
		console.log(sequence_speakers) -->


		
		<!-- 
		
		

					// Declare variables to use
			let speakers = ['First Citizen', 'All', 'Second Citizen', 'Menenius', 'Marcius'];

			// Create a function that takes in csv files with matrices in them and declare the transition matrix
			async function loadMatrixFromCSV(filePath) {
				try {
					const response = await fetch(filePath);
					if (!response.ok) throw new Error(`Failed to fetch ${filePath}`);
					const csvText = await response.text();

					// Use PapaParse to parse CSV text
					const parsed = Papa.parse(csvText.trim(), { skipEmptyLines: true });
					const data = parsed.data;

					//Remove row and column labels from matrix
					const matrix = data.slice(1).map(row =>
						row.slice(1).map(cell => parseFloat(cell))
					);

					return matrix;
				} catch (error) {
					console.error(`‚ùå Error loading ${filePath}:`, error);
					return null;
				}
			}

			const speaker_transition_matrix = await loadMatrixFromCSV('speaker_transition_matrix.csv');



			// Function to simulate Markov chain using a transition matrix
			function simulateMarkov(transitionMatrix, currState) {
				const nextState = new Array(currState.length).fill(0);

				for (let j = 0; j < transitionMatrix[0].length; j++) {
					const stateHolder = new Array(currState.length).fill(0);

					for (let i = 0; i < currState.length; i++) {
						const calc = currState[i] * transitionMatrix[i][j];
						stateHolder[i] = calc;
					}

					nextState[j] = stateHolder.reduce((a, b) => a + b, 0);
				}

				return nextState;
			}

			// Helper function to avoid repeats
				function getMaxIndexExcluding(nextState, noRepeat) {
					let maxVal = -Infinity;
					let maxIndex = -1;

					for (let i = 0; i < nextState.length; i++) {
						if (!noRepeat.includes(i) && nextState[i] > maxVal) {
							maxVal = nextState[i];
							maxIndex = i;
						}
					}

					return maxIndex;
			}

			let item_not_repeat = [];
			let sequence_speakers = new Array(speakers.length).fill("")

				// iteration 1:

				//step 1: get the first speaker
				let speaker = Math.floor(Math.random() * speakers.length);
				item_not_repeat[0] = speaker;

				sequence_speakers[0] = speakers[speaker];

				//step2: make an array for initial current state
				let current_state = Array(speakers.length).fill(0);
				current_state[speaker] = 1;

				//step3: apply the transition matrix to get the next state
				let next_state = simulateMarkov(speaker_transition_matrix, current_state);

				//step4: get the next position from the next_state
				speaker = getMaxIndexExcluding(next_state, item_not_repeat);

				// iterations 2 to speaker's list length minus 1
				let count = 1;
				const maxSteps = speakers.length - 1;

				while (count < maxSteps && speaker !== -1) {

				//step1: Update the no repeat index list and get next speaker
				item_not_repeat[count] = speaker; 
				sequence_speakers[count] = speakers[speaker];
					
				//step2: update current state as previous next state:
				
				current_state = next_state; 
				
				//step3: apply transition matrix to get the next state
				next_state = simulateMarkov(speaker_transition_matrix, current_state);
				
				//step4: get the next position from the next_state
				 speaker = getMaxIndexExcluding(next_state, item_not_repeat);
				 
				 //step5: update the counter 
				 count +=1; 
				}

					
				//iteration final 
				
				//define the item not in the sequence list but in speakers list
				let missing = speakers.find(item => !sequence_speakers.includes(item));

				//find the index where there's a missing name
				let emptyIndex;
				sequence_speakers.forEach((value, index) => {
						if (value === '') {
							emptyIndex = index;
						}
					  });
					  

				//update the sequence with the missing speaker
				sequence_speakers[emptyIndex] = missing;
		

		 console.log(speakers);
		 console.log(missing);
		 console.log(sequence_speakers);
		 console.log(item_not_repeat);
		 
		 //console.log(current_state);
		 //console.log(next_state);



				} -->


	<script type="module">

				// Generate speech per speaker (doing it for All only)
				function speech_generator(speech_transition_matrix, speech_words, speech_word_count) {



					let item_not_repeat = [];

					//Randomly select a number to determine speech length
					let speechLength = Math.floor(Math.random() * speech_word_count.length);

					speechLength = speech_word_count[speechLength]

					//make length of array that holds the length of speech length

					let sequence_words = new Array(speechLength).fill("")

					// iteration 1:

					//step 1: get the first word
					let word = Math.floor(Math.random() * speech_words.length);
					item_not_repeat[0] = word;

					sequence_words[0] = speech_words[word];

					//step2: make an array for initial current state
					let current_state = Array(sequence_words.length).fill(0);
					current_state[speaker] = 1;

					//step3: apply the transition matrix to get the next state
					let next_state = simulateMarkov(speaker_transition_matrix, current_state);

					//step4: get the next position from the next_state
					speaker = getMaxIndexExcluding(next_state, item_not_repeat);

					// iterations 2 to speaker's list length minus 1
					let count = 1;
					const maxSteps = speakers.length - 1;

					while (count < maxSteps && speaker !== -1) {
						//step1: Update the no repeat index list and get next speaker
						item_not_repeat[count] = speaker;

						sequence_speakers[count] = speakers[speaker];

						//step2: update current state as previous next state:
						current_state = next_state;

						//step3: apply transition matrix to get the next state
						next_state = simulateMarkov(speaker_transition_matrix, current_state);

						//step4: get the next position from the next_state
						speaker = getMaxIndexExcluding(next_state, item_not_repeat);

						//step5: update the counter
						count += 1;
					}

					//iteration final

					//define the item not in the sequence list but in speakers list
					const missing = speakers.find(item => !sequence_speakers.includes(item));

					//find the index where there's a missing name in the sequence
					let emptyIndex;
					sequence_speakers.forEach((value, index) => {
						if (value === '') {
							emptyIndex = index;
						}
					});

					//update the sequence with the missing speaker
					sequence_speakers[emptyIndex] = missing;

					// Update speaker tags with generated sequence
					speaker1.textContent = sequence_speakers[0];
					speaker2.textContent = sequence_speakers[1];
					speaker3.textContent = sequence_speakers[2];
					speaker4.textContent = sequence_speakers[3];
					speaker5.textContent = sequence_speakers[4];
				}

	</script>
</body>

</html>